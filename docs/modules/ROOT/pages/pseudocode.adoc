= Pseudocode
:pseudocode-gh-url: https://github.com/SaswatPadhi/pseudocode.js

The documentation embeds some algorithms written using {pseudocode-gh-url}[`pseudocode.js`] whose syntax is mostly compatible with LaTeX package `algorithmic`.

The complete documentation and grammar is available at {pseudocode-gh-url}#grammar[pseudocode.js grammar reference].

IMPORTANT: In order to display pseudocode properly you have to use `[.pseudocode]` on a literal block.

== Basic Structure

Every pseudocode block follows this basic structure:

[.grid.grid-2.gap-2.items-start]
--
.AsciiDoc Source
[source,asciidoc]
----
[.pseudocode]
....
\begin{algorithm}
\caption{Simple Example}
\begin{algorithmic}
\STATE $x \leftarrow 0$
\STATE $y \leftarrow 1$
\RETURN{$x + y$}
\end{algorithmic}
\end{algorithm}
....
----

.Rendered Result
[.pseudocode]
....
\begin{algorithm}
\caption{Simple Example}
\begin{algorithmic}
\STATE $x \leftarrow 0$
\STATE $y \leftarrow 1$
\RETURN{$x + y$}
\end{algorithmic}
\end{algorithm}
....
--

== Available Commands

=== Control Structures

[cols="2,3,3"]
|===
| Command | Syntax | Description

| `\IF{condition}` | `\IF{pass:[condition]} ... \ENDIF` | Conditional statement
| `\ELSIF{condition}` | `\ELSIF{pass:[condition]} ...` | Else-if branch
| `\ELSE` | `\ELSE ...` | Else branch
| `\ENDIF` | `\ENDIF` | End of if block
| `\FOR{loop}` | `\FOR{pass:[loop]} ... \ENDFOR` | For loop
| `\FORALL{condition}` | `\FORALL{pass:[condition]} ... \ENDFOR` | For-all loop
| `\WHILE{condition}` | `\WHILE{pass:[condition]} ... \ENDWHILE` | While loop
| `\REPEAT` | `\REPEAT ... \UNTIL{pass:[condition]}` | Repeat-until loop
| `\UNTIL{condition}` | `\UNTIL{pass:[condition]}` | Until condition
|===

=== Statements and Actions

[cols="2,3,3"]
|===
| Command | Syntax | Description

| `\STATE` | `\STATE pass:[statement]` | General statement
| `\PRINT{text}` | `\PRINT{pass:[text]}` | Print statement
| `\RETURN{value}` | `\RETURN{pass:[value]}` | Return statement
| `\CALL{name}{args}` | `\CALL{pass:[name]}{pass:[args]}` | Function call
| `\COMMENT{text}` | `\COMMENT{pass:[text]}` | Add comment
|===

=== Procedures and Functions

[cols="2,3,3"]
|===
| Command | Syntax | Description

| `\PROCEDURE{name}{args}` | `\PROCEDURE{pass:[name]}{pass:[args]} ... \ENDPROCEDURE` | Define procedure
| `\FUNCTION{name}{args}` | `\FUNCTION{pass:[name]}{pass:[args]} ... \ENDFUNCTION` | Define function
| `\ENDPROCEDURE` | `\ENDPROCEDURE` | End procedure
| `\ENDFUNCTION` | `\ENDFUNCTION` | End function
|===

=== Loop Keywords

[cols="2,3,3"]
|===
| Command | Syntax | Description

| `\TO` | `\FOR{$i = 1$ \TO $n$}` | Range operator
| `\DOWNTO` | `\FOR{$i = n$ \DOWNTO $1$}` | Reverse range
| `\STEP` | `\FOR{$i = 1$ \TO $n$ \STEP $2$}` | Step size
|===

== Complete Examples

=== Example 1: Quicksort Algorithm

[.grid.grid-2.gap-2.items-start]
--
.AsciiDoc Source
[source,asciidoc]
----
[.pseudocode]
....
% Quicksort from Introduction to Algorithms (3rd edition)
\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\PROCEDURE{Quicksort}{$A, p, r$}
    \IF{$p < r$}
        \STATE $q = $ \CALL{Partition}{$A, p, r$}
        \STATE \CALL{Quicksort}{$A, p, q - 1$}
        \STATE \CALL{Quicksort}{$A, q + 1, r$}
    \ENDIF
\ENDPROCEDURE
\PROCEDURE{Partition}{$A, p, r$}
    \STATE $x = A[r]$
    \STATE $i = p - 1$
    \FOR{$j = p$ \TO $r - 1$}
        \IF{$A[j] < x$}
            \STATE $i = i + 1$
            \STATE exchange $A[i]$ with $A[j]$
        \ENDIF
    \ENDFOR
    \STATE exchange $A[i + 1]$ with $A[r]$
    \RETURN{$i + 1$}
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
....
----

.Rendered Result
[.pseudocode]
....
% Quicksort from Introduction to Algorithms (3rd edition)
\begin{algorithm}
\caption{Quicksort}
\begin{algorithmic}
\PROCEDURE{Quicksort}{$A, p, r$}
    \IF{$p < r$}
        \STATE $q = $ \CALL{Partition}{$A, p, r$}
        \STATE \CALL{Quicksort}{$A, p, q - 1$}
        \STATE \CALL{Quicksort}{$A, q + 1, r$}
    \ENDIF
\ENDPROCEDURE
\PROCEDURE{Partition}{$A, p, r$}
    \STATE $x = A[r]$
    \STATE $i = p - 1$
    \FOR{$j = p$ \TO $r - 1$}
        \IF{$A[j] < x$}
            \STATE $i = i + 1$
            \STATE exchange $A[i]$ with $A[j]$
        \ENDIF
    \ENDFOR
    \STATE exchange $A[i + 1]$ with $A[r]$
    \RETURN{$i + 1$}
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
....
--

=== Example 2: Binary Search

[.grid.grid-2.gap-2.items-start]
--
.AsciiDoc Source
[source,asciidoc]
----
[.pseudocode]
....
\begin{algorithm}
\caption{Binary Search}
\begin{algorithmic}
\FUNCTION{BinarySearch}{$A, target, low, high$}
    \WHILE{$low \leq high$}
        \STATE $mid \leftarrow \lfloor (low + high) / 2 \rfloor$
        \IF{$A[mid] = target$}
            \RETURN{$mid$}
        \ELSIF{$A[mid] < target$}
            \STATE $low \leftarrow mid + 1$
        \ELSE
            \STATE $high \leftarrow mid - 1$
        \ENDIF
    \ENDWHILE
    \RETURN{$-1$} \COMMENT{Not found}
\ENDFUNCTION
\end{algorithmic}
\end{algorithm}
....
----

.Rendered Result
[.pseudocode]
....
\begin{algorithm}
\caption{Binary Search}
\begin{algorithmic}
\FUNCTION{BinarySearch}{$A, target, low, high$}
    \WHILE{$low \leq high$}
        \STATE $mid \leftarrow \lfloor (low + high) / 2 \rfloor$
        \IF{$A[mid] = target$}
            \RETURN{$mid$}
        \ELSIF{$A[mid] < target$}
            \STATE $low \leftarrow mid + 1$
        \ELSE
            \STATE $high \leftarrow mid - 1$
        \ENDIF
    \ENDWHILE
    \RETURN{$-1$} \COMMENT{Not found}
\ENDFUNCTION
\end{algorithmic}
\end{algorithm}
....
--

=== Example 3: Graph Traversal

[.grid.grid-2.gap-2.items-start]
--
.AsciiDoc Source
[source,asciidoc]
----
[.pseudocode]
....
\begin{algorithm}
\caption{Breadth-First Search}
\begin{algorithmic}
\PROCEDURE{BFS}{$G, s$}
    \FORALL{$u \in V[G] \setminus \{s\}$}
        \STATE $color[u] \leftarrow WHITE$
        \STATE $d[u] \leftarrow \infty$
        \STATE $\pi[u] \leftarrow NIL$
    \ENDFOR
    \STATE $color[s] \leftarrow GRAY$
    \STATE $d[s] \leftarrow 0$
    \STATE $\pi[s] \leftarrow NIL$
    \STATE $Q \leftarrow \emptyset$
    \STATE \CALL{Enqueue}{$Q, s$}
    \WHILE{$Q \neq \emptyset$}
        \STATE $u \leftarrow$ \CALL{Dequeue}{$Q$}
        \FORALL{$v \in Adj[u]$}
            \IF{$color[v] = WHITE$}
                \STATE $color[v] \leftarrow GRAY$
                \STATE $d[v] \leftarrow d[u] + 1$
                \STATE $\pi[v] \leftarrow u$
                \STATE \CALL{Enqueue}{$Q, v$}
            \ENDIF
        \ENDFOR
        \STATE $color[u] \leftarrow BLACK$
    \ENDWHILE
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
....
----

.Rendered Result
[.pseudocode]
....
\begin{algorithm}
\caption{Breadth-First Search}
\begin{algorithmic}
\PROCEDURE{BFS}{$G, s$}
    \FORALL{$u \in V[G] \setminus \{s\}$}
        \STATE $color[u] \leftarrow WHITE$
        \STATE $d[u] \leftarrow \infty$
        \STATE $\pi[u] \leftarrow NIL$
    \ENDFOR
    \STATE $color[s] \leftarrow GRAY$
    \STATE $d[s] \leftarrow 0$
    \STATE $\pi[s] \leftarrow NIL$
    \STATE $Q \leftarrow \emptyset$
    \STATE \CALL{Enqueue}{$Q, s$}
    \WHILE{$Q \neq \emptyset$}
        \STATE $u \leftarrow$ \CALL{Dequeue}{$Q$}
        \FORALL{$v \in Adj[u]$}
            \IF{$color[v] = WHITE$}
                \STATE $color[v] \leftarrow GRAY$
                \STATE $d[v] \leftarrow d[u] + 1$
                \STATE $\pi[v] \leftarrow u$
                \STATE \CALL{Enqueue}{$Q, v$}
            \ENDIF
        \ENDFOR
        \STATE $color[u] \leftarrow BLACK$
    \ENDWHILE
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
....
--

=== Example 4: Simple Loop Constructs

[.grid.grid-2.gap-2.items-start]
--
.AsciiDoc Source
[source,asciidoc]
----
[.pseudocode]
....
\begin{algorithm}
\caption{Loop Examples}
\begin{algorithmic}
\PROCEDURE{LoopExamples}{$n$}
    \FOR{$i = 0$ \TO $n$}
        \PRINT{$i$}
    \ENDFOR
    
    \FOR{$j = n$ \DOWNTO $1$}
        \PRINT{$j$}
    \ENDFOR
    
    \STATE $x \leftarrow 0$
    \REPEAT
        \STATE $x \leftarrow x + 1$
        \PRINT{$x$}
    \UNTIL{$x = n$}
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
....
----

.Rendered Result
[.pseudocode]
....
\begin{algorithm}
\caption{Loop Examples}
\begin{algorithmic}
\PROCEDURE{LoopExamples}{$n$}
    \FOR{$i = 0$ \TO $n$}
        \PRINT{$i$}
    \ENDFOR
    
    \FOR{$j = n$ \DOWNTO $1$}
        \PRINT{$j$}
    \ENDFOR
    
    \STATE $x \leftarrow 0$
    \REPEAT
        \STATE $x \leftarrow x + 1$
        \PRINT{$x$}
    \UNTIL{$x = n$}
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
....
--

== Mathematical Expressions

Pseudocode.js supports full LaTeX mathematical notation within `$...$` delimiters:

- Variables: `$x, y, z$`
- Subscripts/Superscripts: `$A[i], x^2, log_2(n)$`
- Greek letters: `$\alpha, \beta, \gamma, \pi$`
- Set notation: `$\{1, 2, 3\}, \emptyset, \in, \subset$`
- Mathematical operators: `$\leftarrow, \rightarrow, \leq, \geq, \neq$`
- Functions: `$\lfloor x \rfloor, \lceil x \rceil, \max(a,b)$`

== Comments and Formatting

- Use `%` for single-line comments
- Use `\COMMENT{text}` for inline comments
- Mathematical expressions are automatically rendered with MathJax
- Indentation is handled automatically based on control structures

== Usage Tips

1. **Always use the `.pseudocode` class** on your literal block
2. **Wrap math in dollar signs** for proper rendering
3. **Use proper nesting** of control structures
4. **End blocks explicitly** with appropriate `\END...` commands
5. **Mathematical expressions** are automatically processed by MathJax after pseudocode rendering
